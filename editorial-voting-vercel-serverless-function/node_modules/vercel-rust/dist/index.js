"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldServe = exports.prepareCache = exports.build = exports.version = void 0;
const node_path_1 = __importDefault(require("node:path"));
const node_fs_1 = require("node:fs");
const build_utils_1 = require("@vercel/build-utils");
const execa_1 = __importDefault(require("execa"));
const rust_toolchain_1 = require("./lib/rust-toolchain");
const cargo_1 = require("./lib/cargo");
const utils_1 = require("./lib/utils");
const routes_1 = require("./lib/routes");
function buildHandler(options) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const BUILDER_DEBUG = Boolean((_a = process.env.VERCEL_BUILDER_DEBUG) !== null && _a !== void 0 ? _a : false);
        const { files, entrypoint, workPath, config, meta } = options;
        yield (0, rust_toolchain_1.installRustToolchain)();
        (0, build_utils_1.debug)('Creating file system');
        const downloadedFiles = yield (0, build_utils_1.download)(files, workPath, meta);
        const entryPath = downloadedFiles[entrypoint].fsPath;
        const HOME = process.platform === 'win32' ? (0, utils_1.assertEnv)('USERPROFILE') : (0, utils_1.assertEnv)('HOME');
        const PATH = (0, utils_1.assertEnv)('PATH');
        const rustEnv = {
            PATH: `${node_path_1.default.join(HOME, '.cargo/bin')}:${PATH}`,
            RUSTFLAGS: [process.env.RUSTFLAGS].filter(Boolean).join(' '),
        };
        const cargoWorkspace = yield (0, cargo_1.findCargoWorkspace)({
            env: rustEnv,
            cwd: node_path_1.default.dirname(entryPath),
        });
        const binaryName = (0, cargo_1.findBinaryName)(cargoWorkspace, entryPath);
        const cargoBuildConfiguration = yield (0, cargo_1.findCargoBuildConfiguration)(cargoWorkspace);
        const buildTarget = (_b = cargoBuildConfiguration === null || cargoBuildConfiguration === void 0 ? void 0 : cargoBuildConfiguration.build.target) !== null && _b !== void 0 ? _b : '';
        yield (0, utils_1.runUserScripts)(workPath);
        const extraFiles = yield (0, utils_1.gatherExtraFiles)(config.includeFiles, workPath);
        (0, build_utils_1.debug)(`Running \`cargo build\` for \`${binaryName}\``);
        try {
            yield (0, execa_1.default)('cargo', ['build', '--bin', binaryName].concat(BUILDER_DEBUG ? ['--verbose'] : ['--quiet'], (meta === null || meta === void 0 ? void 0 : meta.isDev) ? [] : ["--release"]), {
                cwd: workPath,
                env: rustEnv,
                stdio: 'inherit',
            });
        }
        catch (err) {
            (0, build_utils_1.debug)(`Running \`cargo build\` for \`${binaryName}\` failed`);
            throw err;
        }
        (0, build_utils_1.debug)(`Building \`${binaryName}\` for \`${process.platform}\` completed`);
        let { target_directory: targetDirectory } = yield (0, cargo_1.getCargoMetadata)({
            cwd: workPath,
            env: rustEnv,
        });
        targetDirectory = node_path_1.default.join(targetDirectory, buildTarget);
        const bin = node_path_1.default.join(targetDirectory, BUILDER_DEBUG ? 'debug' : 'release', (0, utils_1.getExecutableName)(binaryName));
        const lambdaOptions = yield (0, build_utils_1.getLambdaOptionsFromFunction)({
            sourceFile: entrypoint,
            config,
        });
        const bootstrap = (0, utils_1.getExecutableName)('bootstrap');
        const runtime = (meta === null || meta === void 0 ? void 0 : meta.isDev) ? 'provided' : yield (0, build_utils_1.getProvidedRuntime)();
        const lambda = new build_utils_1.Lambda(Object.assign({ files: Object.assign(Object.assign({}, extraFiles), { [bootstrap]: new build_utils_1.FileFsRef({ mode: 0o755, fsPath: bin }) }), handler: bootstrap, runtime }, lambdaOptions));
        lambda.zipBuffer = yield lambda.createZip();
        if (isBundledRoute()) {
            (0, build_utils_1.debug)(`experimental \`route-bundling\` detected - generating single entrypoint`);
            const handlerFiles = yield (0, build_utils_1.glob)('api/**/[!main]*.rs', workPath);
            const routes = (0, routes_1.generateRoutes)(Object.keys(handlerFiles));
            return {
                output: routes.reduce((acc, route) => {
                    acc[route.path] = lambda;
                    return acc;
                }, {}),
                routes: routes.map(({ src, dest }) => ({ src, dest })),
            };
        }
        (0, build_utils_1.debug)(`generating lambda for \`${entrypoint}\``);
        const route = (0, routes_1.parseRoute)(entrypoint);
        return {
            output: {
                [route.path]: lambda,
            },
            routes: [{ src: route.src, dest: route.dest }],
        };
    });
}
function isBundledRoute() {
    if ((0, node_fs_1.existsSync)('api/main.rs')) {
        const content = (0, node_fs_1.readFileSync)('api/main.rs', 'utf8');
        return content.includes('bundled_api]') || content.includes('bundled_api(');
    }
    return false;
}
// Reference -  https://github.com/vercel/vercel/blob/main/DEVELOPING_A_RUNTIME.md#runtime-developer-reference
const runtime = {
    version: 2,
    build: buildHandler,
    prepareCache: ({ workPath }) => __awaiter(void 0, void 0, void 0, function* () {
        (0, build_utils_1.debug)(`Caching \`${workPath}\``);
        const cacheFiles = yield (0, build_utils_1.glob)('target/**', workPath);
        // Convert this into a reduce
        for (const f of Object.keys(cacheFiles)) {
            const accept = /(?:^|\/)target\/release\/\.fingerprint\//.test(f) ||
                /(?:^|\/)target\/release\/build\//.test(f) ||
                /(?:^|\/)target\/release\/deps\//.test(f) ||
                /(?:^|\/)target\/debug\/\.fingerprint\//.test(f) ||
                /(?:^|\/)target\/debug\/build\//.test(f) ||
                /(?:^|\/)target\/debug\/deps\//.test(f);
            if (!accept) {
                delete cacheFiles[f];
            }
        }
        return cacheFiles;
    }),
    shouldServe: (options) => __awaiter(void 0, void 0, void 0, function* () {
        (0, build_utils_1.debug)(`Requested ${options.requestPath} for ${options.entrypoint}`);
        if (isBundledRoute()) {
            return Promise.resolve(options.entrypoint === 'api/main');
        }
        return Promise.resolve(options.requestPath === options.entrypoint);
    }),
};
exports.version = runtime.version, exports.build = runtime.build, exports.prepareCache = runtime.prepareCache, exports.shouldServe = runtime.shouldServe;
